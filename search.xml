<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【LeetCode】2020/3/16</title>
    <url>/2020/03/16/20.3.16/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 其中任一条为空，返回另外一条</span></span><br><span class="line">    <span class="keyword">if</span> l1== <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> l2== <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> result *ListNode</span><br><span class="line">    <span class="comment">// 将较小的节点放入</span></span><br><span class="line">    <span class="keyword">if</span> l1.Val &gt;= l2.Val&#123;</span><br><span class="line">        result = l2</span><br><span class="line">        result.Next = mergeTwoLists(l1,l2.Next)</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        result = l1</span><br><span class="line">        result.Next = mergeTwoLists(l1.Next,l2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">var</span>  res *ListNode</span><br><span class="line">    res = &amp;ListNode&#123;&#125;</span><br><span class="line">    head := res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l1!=<span class="literal">nil</span>&amp;&amp;l2!=<span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &gt;= l2.Val &#123;  </span><br><span class="line">            res.Next = l2</span><br><span class="line">            res = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             res.Next = l1</span><br><span class="line">             res =  l1</span><br><span class="line">             l1 = l1.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l1!=<span class="literal">nil</span>&#123;</span><br><span class="line">        res.Next = l1</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> l2!=<span class="literal">nil</span>&#123;</span><br><span class="line">        res.Next = l2</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.Next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode】2020/1/3</title>
    <url>/2020/01/03/20.1.3/</url>
    <content><![CDATA[<h1 id="20-有效括号"><a href="#20-有效括号" class="headerlink" title="20 有效括号"></a>20 有效括号</h1><ul>
<li>暴力求解，遍历字符串，内建库</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> strings.Contains(s,<span class="string">"&#123;&#125;"</span>)||strings.Contains(s,<span class="string">"[]"</span>)||strings.Contains(s,<span class="string">"()"</span>)&#123;</span><br><span class="line">        s = strings.Replace(s, <span class="string">"&#123;&#125;"</span>, <span class="string">""</span>, <span class="number">-1</span>)</span><br><span class="line">        s = strings.Replace(s, <span class="string">"[]"</span>, <span class="string">""</span>, <span class="number">-1</span>)</span><br><span class="line">        s = strings.Replace(s, <span class="string">"()"</span>, <span class="string">""</span>, <span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s!=<span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈</li>
</ul>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    stack :=NewStack()</span><br><span class="line">    <span class="keyword">for</span> _,v :=<span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> v ==<span class="string">'&#123;'</span>||v==<span class="string">'('</span>||v==<span class="string">'['</span>&#123;</span><br><span class="line">            stack.Push(v)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>  v==<span class="string">'&#125;'</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> stack.Peak()==<span class="string">'&#123;'</span>&#123;</span><br><span class="line">                stack.Pop()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">if</span>  v==<span class="string">')'</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> stack.Peak()==<span class="string">'('</span>&#123;</span><br><span class="line">                stack.Pop()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">if</span>  v==<span class="string">']'</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> stack.Peak()==<span class="string">'['</span>&#123;</span><br><span class="line">                stack.Pop()</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> stack.Empty()&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">\\栈的实现</span><br><span class="line"><span class="keyword">package</span> stack</span><br><span class="line"><span class="keyword">import</span> <span class="string">"container/list"</span></span><br><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    list *list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStack</span><span class="params">()</span> *<span class="title">Stack</span></span> &#123;</span><br><span class="line">    list := list.New()</span><br><span class="line">    <span class="keyword">return</span> &amp;Stack&#123;list&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Push</span><span class="params">(value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    stack.list.PushBack(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    e := stack.list.Back()</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        stack.list.Remove(e)</span><br><span class="line">        <span class="keyword">return</span> e.Value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Peak</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    e := stack.list.Back()</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> e.Value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.list.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stack *Stack)</span> <span class="title">Empty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stack.list.Len() == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode】2019/12/21</title>
    <url>/2019/12/21/19.12.21/</url>
    <content><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>给定 nums = [0,0,1,1,1,2,2,3,3,4],<br>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。<br>你不需要考虑数组中超出新长度后面的元素。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>拿到题目的时候首先确定题意，分析清楚输入和输出。<br>考虑可以使用的方法，对于数组来说，同一个数组可以有多个指针，只要互不影响，就ok</p>
<p>首先返回的新数组中元素的个数 = 数组长度<br>因为是连续存储所以你只需要指向最有一个元素即可<br>需要几个变量？ 变量之间是否有相关性？</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i]!=v&#123;</span><br><span class="line">            i++</span><br><span class="line">            nums[i]=v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="189">
<li>旋转数组<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">        k = k%<span class="built_in">len</span>(nums)<span class="comment">//注意k值超出数组长度的时候，取余</span></span><br><span class="line">        nums1 := nums[<span class="number">0</span>:<span class="built_in">len</span>(nums)-k]</span><br><span class="line">        nums2 := nums[<span class="built_in">len</span>(nums)-k:<span class="built_in">len</span>(nums)]</span><br><span class="line">        reverse(nums1)</span><br><span class="line">        reverse(nums2)</span><br><span class="line">        reverse(nums)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span> <span class="params">(nums []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; <span class="built_in">len</span>(nums)/<span class="number">2</span>;i++&#123;</span><br><span class="line">        nums[i],nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>] = nums[<span class="built_in">len</span>(nums)-i<span class="number">-1</span>],nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode】2019/12/10</title>
    <url>/2019/12/10/19.12.10/</url>
    <content><![CDATA[<h1 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11\盛水最多的容器"></a>11\盛水最多的容器</h1><h2 id="双指针，关于解算法题的思考，求解问题。计算思维"><a href="#双指针，关于解算法题的思考，求解问题。计算思维" class="headerlink" title="双指针，关于解算法题的思考，求解问题。计算思维"></a>双指针，关于解算法题的思考，求解问题。计算思维</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">全部的解空间为C(2,n)，无序对。</span></span><br><span class="line"><span class="comment">1、确保覆盖全部解空间，确保每次丢掉的解空间一定小于等于最优解,你觉得没考虑的情况实际上已经才一次操作后考虑过了</span></span><br><span class="line"><span class="comment">2、考虑MaxArea = min(height[j]，height[i])*(j-i),往内收缩的时候丢掉的解集，一定小于当前的解</span></span><br><span class="line"><span class="comment">因为解集的大小取决于高度最小的一个</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> maxArea <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i!=j &#123;</span><br><span class="line">        <span class="keyword">var</span> Area <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">if</span>(height[i]&gt;height[j])&#123;</span><br><span class="line">            Area = height[j]*(j-i)</span><br><span class="line">            j--</span><br><span class="line">        &#125;  <span class="keyword">else</span>&#123;</span><br><span class="line">            Area = height[i]*(j-i)</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Area&gt;maxArea)&#123;</span><br><span class="line">            maxArea = Area</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历全部解空间 ，找到最优解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> maxArea <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(height)<span class="number">-1</span>;i++&#123;</span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(height);j++&#123;</span><br><span class="line">            area:=min(height[i],height[j])*(j<span class="number">-1</span>)</span><br><span class="line">               <span class="keyword">if</span> area&gt;maxArea&#123;</span><br><span class="line">                   maxArea= area</span><br><span class="line">               &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">( x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
</search>
